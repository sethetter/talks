<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>notes</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="./notes.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="types-are-your-friends">Types are your friends!</h1>
<ul>
<li><strong>What are types?</strong>
<ul>
<li>In a programming language, all variables have a <strong>type</strong>.
<ul>
<li>Primitives: string, integer, function, object, array</li>
<li>Domain Specific: LoginRequest, User, BlogPost</li>
</ul></li>
</ul></li>
<li><strong>Programming languages can be typed in different ways.</strong>
<ul>
<li>Dynamically typed
<ul>
<li>No need to specify types in your code, they’re determined at runtime.</li>
<li>Type incompatibilities turn into runtime errors.</li>
<li>Example: <code>001.js</code></li>
</ul></li>
<li>Statically typed
<ul>
<li>You specify in your code what type a variable is, what types a function accepts as arguments, and returns as values.</li>
<li>Before the program is executed, analysis is performed to verify that the right types are used in the right places, and no violations exist.</li>
<li>Example: <code>001.ts</code></li>
</ul></li>
<li>Many other categories of type systems in between <strong>static</strong> and <strong>dynamic</strong>.
<ul>
<li>Duck typing, gradual typing, optional typing, etc.</li>
</ul></li>
</ul></li>
<li><strong>Arguments for dynamic typing.</strong>
<ul>
<li>Less cognitive overhead; just write your code and don’t worry about types.</li>
<li>More flexibility; avoid restriction that a type system might impose.</li>
</ul></li>
<li><strong>Valid arguments, but I’m here to convince you that static is better.</strong>
<ul>
<li>Prevent an entire class of potential coding errors, for free.
<ul>
<li>Any code that misuses a type is caught during compilation.
<ul>
<li>Even better, during development!</li>
</ul></li>
</ul></li>
<li>Refactor your codebase with confidence.
<ul>
<li>Encode changes into the types, compiler guides you through the rest.</li>
</ul></li>
<li>More information at your fingertips.
<ul>
<li>We can read source code and understand behavior.</li>
<li>Types provide more information for understanding and shaping our program.</li>
</ul></li>
</ul></li>
</ul>
<h2 id="examples">Examples</h2>
<ul>
<li><strong>Preventing type errors during runtime.</strong>
<ul>
<li>Example: <code>02.js</code>
<ul>
<li>This file has an error, and maybe you can spot it quickly, but..</li>
<li>When we try to run it, we get weird, unhelpful behavior.</li>
<li>The <em>information</em> we’ve received (<code>undefined</code>) is very indirect.</li>
</ul></li>
<li>Example: <code>02.ts</code>
<ul>
<li>The same error exists here, but, the compiler catches it immediately.</li>
<li>A bit more code required to define the interface.</li>
<li>But even a simple example shows that a small time investment up front empowers the tooling to prevent runtime errors.</li>
</ul></li>
</ul></li>
<li><strong>Refactor with confidence.</strong>
<ul>
<li>Example: <code>03.js</code>
<ul>
<li>What if the <code>location</code> property is renamed to <code>address</code>?</li>
<li>Find and replace?</li>
</ul></li>
<li>Example: <code>03.ts</code>
<ul>
<li>Shape of data changed.</li>
<li>Update <code>address</code> property name, and move name inside address.</li>
</ul></li>
</ul></li>
<li><strong>Working with types.</strong>
<ul>
<li><strong>Example</strong>: Express API with external API as data source.</li>
<li>Type hints and info as we work with our tools.
<ul>
<li>Express route handler function.</li>
</ul></li>
<li>Request and response objects.
<ul>
<li>Fetch response object.</li>
</ul></li>
<li>Catching common mistakes.
<ul>
<li>Simple mistakes.</li>
<li>Possible <code>undefined</code> usage.</li>
<li>Handling promises from <code>async</code> functions.</li>
</ul></li>
<li>Defining data structures first.
<ul>
<li>Request and response objects.</li>
<li>TMDB API responses.</li>
</ul></li>
</ul></li>
<li><strong>Ultimately, choose the right tool for the job, dependent on many factors.</strong>
<ul>
<li>What is it that you’re building?</li>
<li>How big and long-lived will the code base be?</li>
<li>What’s the staffing situation? Company/personal experience?</li>
<li>The list goes on..</li>
</ul></li>
</ul>
</body>
</html>
